module.exports = {

"[project]/node_modules/q/q.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */ (function(definition) {
    "use strict";
    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.
    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);
    // CommonJS
    } else if ("TURBOPACK compile-time truthy", 1) {
        module.exports = definition();
    // RequireJS
    } else //TURBOPACK unreachable
    {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global;
        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ;
    }
})(function() {
    "use strict";
    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }
    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;
    // shims
    // used for fallback in "allResolved"
    var noop = function() {};
    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick = function() {
        // linked list of tasks (single, with head node)
        var head = {
            task: void 0,
            next: null
        };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        // queue for late tasks, used by unhandled rejection tracking
        var laterQueue = [];
        function flush() {
            /* jshint loopfunc: true */ var task, domain;
            while(head.next){
                head = head.next;
                task = head.task;
                head.task = void 0;
                domain = head.domain;
                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
                runSingle(task, domain);
            }
            while(laterQueue.length){
                task = laterQueue.pop();
                runSingle(task);
            }
            flushing = false;
        }
        // runs a single function in the async queue
        function runSingle(task, domain) {
            try {
                task();
            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!
                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }
                    throw e;
                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                        throw e;
                    }, 0);
                }
            }
            if (domain) {
                domain.exit();
            }
        }
        nextTick = function(task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
            // Ensure Q is in a real Node environment, with a `process.nextTick`.
            // To see through fake Node environments:
            // * Mocha test runner - exposes a `process` global without a `nextTick`
            // * Browserify - exposes a `process.nexTick` function that uses
            //   `setTimeout`. In this case `setImmediate` is preferred because
            //    it is faster. Browserify's `process.toString()` yields
            //   "[object Object]", while in a real Node environment
            //   `process.toString()` yields "[object process]".
            isNodeJS = true;
            requestTick = function() {
                process.nextTick(flush);
            };
        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            else {
                requestTick = function() {
                    setImmediate(flush);
                };
            }
        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function() {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function() {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function() {
                setTimeout(flush, 0);
                requestPortTick();
            };
        } else {
            // old browsers
            requestTick = function() {
                setTimeout(flush, 0);
            };
        }
        // runs a task after all other tasks have been run
        // this is useful for unhandled rejection tracking that needs to happen
        // after all `then`d tasks have been run.
        nextTick.runAfter = function(task) {
            laterQueue.push(task);
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        return nextTick;
    }();
    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you don’t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Miller’s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function() {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis
    var array_slice = uncurryThis(Array.prototype.slice);
    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {
        var index = 0, length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            }while (1)
        }
        // reduce
        for(; index < length; index++){
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    });
    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {
        // not a very good shim, but good enough for our one use of it
        for(var i = 0; i < this.length; i++){
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    });
    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function(undefined1, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    });
    var object_create = Object.create || function(prototype) {
        function Type() {}
        Type.prototype = prototype;
        return new Type();
    };
    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
        obj[prop] = descriptor.value;
        return obj;
    };
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var object_keys = Object.keys || function(object) {
        var keys = [];
        for(var key in object){
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    var object_toString = uncurryThis(Object.prototype.toString);
    function isObject(value) {
        return value === Object(value);
    }
    // generator related shims
    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
    }
    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function(value) {
            this.value = value;
        };
    }
    // long stack traces
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack) {
            var stacks = [];
            for(var p = promise; !!p; p = p.source){
                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                    object_defineProperty(error, "__minimumStackCounter__", {
                        value: p.stackCounter,
                        configurable: true
                    });
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            var stack = filterStackString(concatedStacks);
            object_defineProperty(error, "stack", {
                value: stack,
                configurable: true
            });
        }
    }
    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for(var i = 0; i < lines.length; ++i){
            var line = lines[i];
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }
    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [
                attempt1[1],
                Number(attempt1[2])
            ];
        }
        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [
                attempt2[1],
                Number(attempt2[2])
            ];
        }
        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [
                attempt3[1],
                Number(attempt3[2])
            ];
        }
    }
    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
            return false;
        }
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
    }
    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }
        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }
            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }
    function deprecate(callback, name, alternative) {
        return function() {
            if (typeof console !== "undefined" && typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }
    // end of shims
    // beginning of real work
    /**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */ function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }
        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;
    /**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */ Q.nextTick = nextTick;
    /**
 * Controls whether or not long stack traces will be on
 */ Q.longStackSupport = false;
    /**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */ var longStackCounter = 1;
    // enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }
    /**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */ Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;
        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);
        promise.promiseDispatch = function(resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) {
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function() {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };
        // XXX deprecated
        promise.valueOf = function() {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };
        promise.inspect = function() {
            if (!resolvedPromise) {
                return {
                    state: "pending"
                };
            }
            return resolvedPromise.inspect();
        };
        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
                promise.stackCounter = longStackCounter++;
            }
        }
        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
        function become(newPromise) {
            resolvedPromise = newPromise;
            if (Q.longStackSupport && hasStacks) {
                // Only hold a reference to the new promise if long stacks
                // are enabled to reduce memory usage
                promise.source = newPromise;
            }
            array_reduce(messages, function(undefined1, message) {
                Q.nextTick(function() {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);
            messages = void 0;
            progressListeners = void 0;
        }
        deferred.promise = promise;
        deferred.resolve = function(value) {
            if (resolvedPromise) {
                return;
            }
            become(Q(value));
        };
        deferred.fulfill = function(value) {
            if (resolvedPromise) {
                return;
            }
            become(fulfill(value));
        };
        deferred.reject = function(reason) {
            if (resolvedPromise) {
                return;
            }
            become(reject(reason));
        };
        deferred.notify = function(progress) {
            if (resolvedPromise) {
                return;
            }
            array_reduce(progressListeners, function(undefined1, progressListener) {
                Q.nextTick(function() {
                    progressListener(progress);
                });
            }, void 0);
        };
        return deferred;
    }
    /**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */ defer.prototype.makeNodeResolver = function() {
        var self = this;
        return function(error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };
    /**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */ Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }
    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6
    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function(object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };
    Promise.prototype.passByCopy = function() {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };
    /**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */ Q.join = function(x, y) {
        return Q(x).join(y);
    };
    Promise.prototype.join = function(that) {
        return Q([
            this,
            that
        ]).spread(function(x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Q can't join: not the same: " + x + " " + y);
            }
        });
    };
    /**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */ Q.race = race;
    function race(answerPs) {
        return promise(function(resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function (answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for(var i = 0, len = answerPs.length; i < len; i++){
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }
    Promise.prototype.race = function() {
        return this.then(Q.race);
    };
    /**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */ Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function(op) {
                return reject(new Error("Promise does not support operation: " + op));
            };
        }
        if (inspect === void 0) {
            inspect = function() {
                return {
                    state: "unknown"
                };
            };
        }
        var promise = object_create(Promise.prototype);
        promise.promiseDispatch = function(resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };
        promise.inspect = inspect;
        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }
            promise.valueOf = function() {
                var inspected = inspect();
                if (inspected.state === "pending" || inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }
        return promise;
    }
    Promise.prototype.toString = function() {
        return "[object Promise]";
    };
    Promise.prototype.then = function(fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false; // ensure the untrusted promise makes at most a
        // single call to one of the callbacks
        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }
        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }
        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }
        Q.nextTick(function() {
            self.promiseDispatch(function(value) {
                if (done) {
                    return;
                }
                done = true;
                deferred.resolve(_fulfilled(value));
            }, "when", [
                function(exception) {
                    if (done) {
                        return;
                    }
                    done = true;
                    deferred.resolve(_rejected(exception));
                }
            ]);
        });
        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [
            void 0,
            function(value) {
                var newValue;
                var threw = false;
                try {
                    newValue = _progressed(value);
                } catch (e) {
                    threw = true;
                    if (Q.onerror) {
                        Q.onerror(e);
                    } else {
                        throw e;
                    }
                }
                if (!threw) {
                    deferred.notify(newValue);
                }
            }
        ]);
        return deferred.promise;
    };
    Q.tap = function(promise, callback) {
        return Q(promise).tap(callback);
    };
    /**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */ Promise.prototype.tap = function(callback) {
        callback = Q(callback);
        return this.then(function(value) {
            return callback.fcall(value).thenResolve(value);
        });
    };
    /**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */ Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }
    Promise.prototype.thenResolve = function(value) {
        return this.then(function() {
            return value;
        });
    };
    Q.thenResolve = function(promise, value) {
        return Q(promise).thenResolve(value);
    };
    Promise.prototype.thenReject = function(reason) {
        return this.then(function() {
            throw reason;
        });
    };
    Q.thenReject = function(promise, reason) {
        return Q(promise).thenReject(reason);
    };
    /**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */ // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }
    /**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */ Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }
    /**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */ Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }
    Promise.prototype.isPending = function() {
        return this.inspect().state === "pending";
    };
    /**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */ Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    Promise.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
    };
    /**
 * @returns whether the given object is a rejected promise.
 */ Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }
    Promise.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
    };
    //// BEGIN UNHANDLED REJECTION TRACKING
    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }
    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function() {
                if (array_indexOf(unhandledRejections, promise) !== -1) {
                    process.emit("unhandledRejection", reason, promise);
                    reportedUnhandledRejections.push(promise);
                }
            });
        }
        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }
    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }
        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
                Q.nextTick.runAfter(function() {
                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
                    if (atReport !== -1) {
                        process.emit("rejectionHandled", unhandledReasons[at], promise);
                        reportedUnhandledRejections.splice(atReport, 1);
                    }
                });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }
    Q.resetUnhandledRejections = resetUnhandledRejections;
    Q.getUnhandledReasons = function() {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };
    Q.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };
    resetUnhandledRejections();
    //// END UNHANDLED REJECTION TRACKING
    /**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */ Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function(rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return {
                state: "rejected",
                reason: reason
            };
        });
        // Note that the reason has not been handled.
        trackRejection(rejection, reason);
        return rejection;
    }
    /**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */ Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function() {
                return value;
            },
            "get": function(name) {
                return value[name];
            },
            "set": function(name, rhs) {
                value[name] = rhs;
            },
            "delete": function(name) {
                delete value[name];
            },
            "post": function(name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function(thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function() {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return {
                state: "fulfilled",
                value: value
            };
        });
    }
    /**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */ function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function() {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }
    /**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */ Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function() {}
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function() {
            return Q(object).inspect();
        });
    }
    /**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */ Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }
    Promise.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };
    /**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */ Q.async = async;
    function async(makeGenerator) {
        return function() {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;
                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.
                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }
    /**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */ Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }
    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */ Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }
    /**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */ Q.promised = promised;
    function promised(callback) {
        return function() {
            return spread([
                this,
                all(arguments)
            ], function(self, args) {
                return callback.apply(self, args);
            });
        };
    }
    /**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */ Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }
    Promise.prototype.dispatch = function(op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function() {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };
    /**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */ Q.get = function(object, key) {
        return Q(object).dispatch("get", [
            key
        ]);
    };
    Promise.prototype.get = function(key) {
        return this.dispatch("get", [
            key
        ]);
    };
    /**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */ Q.set = function(object, key, value) {
        return Q(object).dispatch("set", [
            key,
            value
        ]);
    };
    Promise.prototype.set = function(key, value) {
        return this.dispatch("set", [
            key,
            value
        ]);
    };
    /**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */ Q.del = Q["delete"] = function(object, key) {
        return Q(object).dispatch("delete", [
            key
        ]);
    };
    Promise.prototype.del = Promise.prototype["delete"] = function(key) {
        return this.dispatch("delete", [
            key
        ]);
    };
    /**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */ // bound locally because it is used by other methods
    Q.mapply = Q.post = function(object, name, args) {
        return Q(object).dispatch("post", [
            name,
            args
        ]);
    };
    Promise.prototype.mapply = Promise.prototype.post = function(name, args) {
        return this.dispatch("post", [
            name,
            args
        ]);
    };
    /**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */ Q.send = Q.mcall = Q.invoke = function(object, name /*...args*/ ) {
        return Q(object).dispatch("post", [
            name,
            array_slice(arguments, 2)
        ]);
    };
    Promise.prototype.send = Promise.prototype.mcall = Promise.prototype.invoke = function(name /*...args*/ ) {
        return this.dispatch("post", [
            name,
            array_slice(arguments, 1)
        ]);
    };
    /**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */ Q.fapply = function(object, args) {
        return Q(object).dispatch("apply", [
            void 0,
            args
        ]);
    };
    Promise.prototype.fapply = function(args) {
        return this.dispatch("apply", [
            void 0,
            args
        ]);
    };
    /**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */ Q["try"] = Q.fcall = function(object /* ...args*/ ) {
        return Q(object).dispatch("apply", [
            void 0,
            array_slice(arguments, 1)
        ]);
    };
    Promise.prototype.fcall = function() {
        return this.dispatch("apply", [
            void 0,
            array_slice(arguments)
        ]);
    };
    /**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */ Q.fbind = function(object /*...args*/ ) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function() {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    /**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */ Q.keys = function(object) {
        return Q(object).dispatch("keys", []);
    };
    Promise.prototype.keys = function() {
        return this.dispatch("keys", []);
    };
    /**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */ // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function(promises) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises, function(undefined1, promise, index) {
                var snapshot;
                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
                    promises[index] = snapshot.value;
                } else {
                    ++pendingCount;
                    when(promise, function(value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    }, deferred.reject, function(progress) {
                        deferred.notify({
                            index: index,
                            value: progress
                        });
                    });
                }
            }, void 0);
            if (pendingCount === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }
    Promise.prototype.all = function() {
        return all(this);
    };
    /**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */ Q.any = any;
    function any(promises) {
        if (promises.length === 0) {
            return Q.resolve();
        }
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function(prev, current, index) {
            var promise = promises[index];
            pendingCount++;
            when(promise, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
                deferred.resolve(result);
            }
            function onRejected(err) {
                pendingCount--;
                if (pendingCount === 0) {
                    var rejection = err || new Error("" + err);
                    rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
                    deferred.reject(rejection);
                }
            }
            function onProgress(progress) {
                deferred.notify({
                    index: index,
                    value: progress
                });
            }
        }, undefined);
        return deferred.promise;
    }
    Promise.prototype.any = function() {
        return any(this);
    };
    /**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */ Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function(promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function(promise) {
                return when(promise, noop, noop);
            })), function() {
                return promises;
            });
        });
    }
    Promise.prototype.allResolved = function() {
        return allResolved(this);
    };
    /**
 * @see Promise#allSettled
 */ Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }
    /**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */ Promise.prototype.allSettled = function() {
        return this.then(function(promises) {
            return all(array_map(promises, function(promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };
    /**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */ Q.fail = Q["catch"] = function(object, rejected) {
        return Q(object).then(void 0, rejected);
    };
    Promise.prototype.fail = Promise.prototype["catch"] = function(rejected) {
        return this.then(void 0, rejected);
    };
    /**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */ Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }
    Promise.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
    };
    /**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */ Q.fin = Q["finally"] = function(object, callback) {
        return Q(object)["finally"](callback);
    };
    Promise.prototype.fin = Promise.prototype["finally"] = function(callback) {
        if (!callback || typeof callback.apply !== "function") {
            throw new Error("Q can't apply finally callback");
        }
        callback = Q(callback);
        return this.then(function(value) {
            return callback.fcall().then(function() {
                return value;
            });
        }, function(reason) {
            // TODO attempt to recycle the rejection with "this".
            return callback.fcall().then(function() {
                throw reason;
            });
        });
    };
    /**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */ Q.done = function(object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };
    Promise.prototype.done = function(fulfilled, rejected, progress) {
        var onUnhandledError = function(error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function() {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };
        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }
        promise.then(void 0, onUnhandledError);
    };
    /**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */ Q.timeout = function(object, ms, error) {
        return Q(object).timeout(ms, error);
    };
    Promise.prototype.timeout = function(ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function() {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);
        this.then(function(value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function(exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);
        return deferred.promise;
    };
    /**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */ Q.delay = function(object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };
    Promise.prototype.delay = function(timeout) {
        return this.then(function(value) {
            var deferred = defer();
            setTimeout(function() {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };
    /**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */ Q.nfapply = function(callback, args) {
        return Q(callback).nfapply(args);
    };
    Promise.prototype.nfapply = function(args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    /**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */ Q.nfcall = function(callback /*...args*/ ) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };
    Promise.prototype.nfcall = function() {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    /**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */ Q.nfbind = Q.denodeify = function(callback /*...args*/ ) {
        if (callback === undefined) {
            throw new Error("Q can't wrap an undefined function");
        }
        var baseArgs = array_slice(arguments, 1);
        return function() {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    Promise.prototype.nfbind = Promise.prototype.denodeify = function() {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
    };
    Q.nbind = function(callback, thisp /*...args*/ ) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    Promise.prototype.nbind = function() {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };
    /**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */ Q.nmapply = Q.npost = function(object, name, args) {
        return Q(object).npost(name, args);
    };
    Promise.prototype.nmapply = Promise.prototype.npost = function(name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [
            name,
            nodeArgs
        ]).fail(deferred.reject);
        return deferred.promise;
    };
    /**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */ Q.nsend = Q.nmcall = Q.ninvoke = function(object, name /*...args*/ ) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [
            name,
            nodeArgs
        ]).fail(deferred.reject);
        return deferred.promise;
    };
    Promise.prototype.nsend = Promise.prototype.nmcall = Promise.prototype.ninvoke = function(name /*...args*/ ) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [
            name,
            nodeArgs
        ]).fail(deferred.reject);
        return deferred.promise;
    };
    /**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */ Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }
    Promise.prototype.nodeify = function(nodeback) {
        if (nodeback) {
            this.then(function(value) {
                Q.nextTick(function() {
                    nodeback(null, value);
                });
            }, function(error) {
                Q.nextTick(function() {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };
    Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
    };
    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();
    return Q;
});
}}),
"[project]/node_modules/formidable/src/PersistentFile.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
;
;
;
class PersistentFile extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["EventEmitter"] {
    constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm }){
        super();
        this.lastModifiedDate = null;
        Object.assign(this, {
            filepath,
            newFilename,
            originalFilename,
            mimetype,
            hashAlgorithm
        });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === 'string') {
            this.hash = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].createHash(this.hashAlgorithm);
        } else {
            this.hash = null;
        }
    }
    open() {
        this._writeStream = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].createWriteStream(this.filepath);
        this._writeStream.on('error', (err)=>{
            this.emit('error', err);
        });
    }
    toJSON() {
        const json = {
            size: this.size,
            filepath: this.filepath,
            newFilename: this.newFilename,
            mimetype: this.mimetype,
            mtime: this.lastModifiedDate,
            length: this.length,
            originalFilename: this.originalFilename
        };
        if (this.hash && this.hash !== '') {
            json.hash = this.hash;
        }
        return json;
    }
    toString() {
        return `PersistentFile: ${this.newFilename}, Original: ${this.originalFilename}, Path: ${this.filepath}`;
    }
    write(buffer, cb) {
        if (this.hash) {
            this.hash.update(buffer);
        }
        if (this._writeStream.closed) {
            cb();
            return;
        }
        this._writeStream.write(buffer, ()=>{
            this.lastModifiedDate = new Date();
            this.size += buffer.length;
            this.emit('progress', this.size);
            cb();
        });
    }
    end(cb) {
        if (this.hash) {
            this.hash = this.hash.digest('hex');
        }
        this._writeStream.end(()=>{
            this.emit('end');
            cb();
        });
    }
    destroy() {
        this._writeStream.destroy();
        const filepath = this.filepath;
        setTimeout(function() {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].unlink(filepath, ()=>{});
        }, 1);
    }
}
const __TURBOPACK__default__export__ = PersistentFile;
}),
"[project]/node_modules/formidable/src/VolatileFile.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
;
;
class VolatileFile extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["EventEmitter"] {
    constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream }){
        super();
        this.lastModifiedDate = null;
        Object.assign(this, {
            filepath,
            newFilename,
            originalFilename,
            mimetype,
            hashAlgorithm,
            createFileWriteStream
        });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === 'string') {
            this.hash = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHash"])(this.hashAlgorithm);
        } else {
            this.hash = null;
        }
    }
    open() {
        this._writeStream = this.createFileWriteStream(this);
        this._writeStream.on('error', (err)=>{
            this.emit('error', err);
        });
    }
    destroy() {
        this._writeStream.destroy();
    }
    toJSON() {
        const json = {
            size: this.size,
            newFilename: this.newFilename,
            length: this.length,
            originalFilename: this.originalFilename,
            mimetype: this.mimetype
        };
        if (this.hash && this.hash !== '') {
            json.hash = this.hash;
        }
        return json;
    }
    toString() {
        return `VolatileFile: ${this.originalFilename}`;
    }
    write(buffer, cb) {
        if (this.hash) {
            this.hash.update(buffer);
        }
        if (this._writeStream.closed || this._writeStream.destroyed) {
            cb();
            return;
        }
        this._writeStream.write(buffer, ()=>{
            this.size += buffer.length;
            this.emit('progress', this.size);
            cb();
        });
    }
    end(cb) {
        if (this.hash) {
            this.hash = this.hash.digest('hex');
        }
        this._writeStream.end(()=>{
            this.emit('end');
            cb();
        });
    }
}
const __TURBOPACK__default__export__ = VolatileFile;
}),
"[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "aborted": ()=>aborted,
    "biggerThanMaxFileSize": ()=>biggerThanMaxFileSize,
    "biggerThanTotalMaxFileSize": ()=>biggerThanTotalMaxFileSize,
    "cannotCreateDir": ()=>cannotCreateDir,
    "default": ()=>__TURBOPACK__default__export__,
    "filenameNotString": ()=>filenameNotString,
    "malformedMultipart": ()=>malformedMultipart,
    "maxFieldsExceeded": ()=>maxFieldsExceeded,
    "maxFieldsSizeExceeded": ()=>maxFieldsSizeExceeded,
    "maxFilesExceeded": ()=>maxFilesExceeded,
    "missingContentType": ()=>missingContentType,
    "missingMultipartBoundary": ()=>missingMultipartBoundary,
    "missingPlugin": ()=>missingPlugin,
    "noEmptyFiles": ()=>noEmptyFiles,
    "noParser": ()=>noParser,
    "pluginFailed": ()=>pluginFailed,
    "pluginFunction": ()=>pluginFunction,
    "smallerThanMinFileSize": ()=>smallerThanMinFileSize,
    "uninitializedParser": ()=>uninitializedParser,
    "unknownTransferEncoding": ()=>unknownTransferEncoding
});
const missingPlugin = 1000;
const pluginFunction = 1001;
const aborted = 1002;
const noParser = 1003;
const uninitializedParser = 1004;
const filenameNotString = 1005;
const maxFieldsSizeExceeded = 1006;
const maxFieldsExceeded = 1007;
const smallerThanMinFileSize = 1008;
const biggerThanTotalMaxFileSize = 1009;
const noEmptyFiles = 1010;
const missingContentType = 1011;
const malformedMultipart = 1012;
const missingMultipartBoundary = 1013;
const unknownTransferEncoding = 1014;
const maxFilesExceeded = 1015;
const biggerThanMaxFileSize = 1016;
const pluginFailed = 1017;
const cannotCreateDir = 1018;
const FormidableError = class extends Error {
    constructor(message, internalCode, httpCode = 500){
        super(message);
        this.code = internalCode;
        this.httpCode = httpCode;
    }
};
;
const __TURBOPACK__default__export__ = FormidableError;
}),
"[project]/node_modules/formidable/src/parsers/Dummy.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
class DummyParser extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Transform"] {
    constructor(incomingForm, options = {}){
        super();
        this.globalOptions = {
            ...options
        };
        this.incomingForm = incomingForm;
    }
    _flush(callback) {
        this.incomingForm.ended = true;
        this.incomingForm._maybeEnd();
        callback();
    }
}
const __TURBOPACK__default__export__ = DummyParser;
}),
"[project]/node_modules/formidable/src/parsers/Multipart.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-fallthrough */ /* eslint-disable no-bitwise */ /* eslint-disable no-plusplus */ /* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "STATES": ()=>STATES,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)");
;
;
;
let s = 0;
const STATE = {
    PARSER_UNINITIALIZED: s++,
    START: s++,
    START_BOUNDARY: s++,
    HEADER_FIELD_START: s++,
    HEADER_FIELD: s++,
    HEADER_VALUE_START: s++,
    HEADER_VALUE: s++,
    HEADER_VALUE_ALMOST_DONE: s++,
    HEADERS_ALMOST_DONE: s++,
    PART_DATA_START: s++,
    PART_DATA: s++,
    PART_END: s++,
    END: s++
};
let f = 1;
const FBOUNDARY = {
    PART_BOUNDARY: f,
    LAST_BOUNDARY: f *= 2
};
const LF = 10;
const CR = 13;
const SPACE = 32;
const HYPHEN = 45;
const COLON = 58;
const A = 97;
const Z = 122;
function lower(c) {
    return c | 0x20;
}
const STATES = {};
Object.keys(STATE).forEach((stateName)=>{
    STATES[stateName] = STATE[stateName];
});
class MultipartParser extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Transform"] {
    constructor(options = {}){
        super({
            readableObjectMode: true
        });
        this.boundary = null;
        this.boundaryChars = null;
        this.lookbehind = null;
        this.bufferLength = 0;
        this.state = STATE.PARSER_UNINITIALIZED;
        this.globalOptions = {
            ...options
        };
        this.index = null;
        this.flags = 0;
    }
    _endUnexpected() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["malformedMultipart"], 400);
    }
    _flush(done) {
        if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {
            this._handleCallback('partEnd');
            this._handleCallback('end');
            done();
        } else if (this.state !== STATE.END) {
            done(this._endUnexpected());
        } else {
            done();
        }
    }
    initWithBoundary(str) {
        this.boundary = Buffer.from(`\r\n--${str}`);
        this.lookbehind = Buffer.alloc(this.boundary.length + 8);
        this.state = STATE.START;
        this.boundaryChars = {};
        for(let i = 0; i < this.boundary.length; i++){
            this.boundaryChars[this.boundary[i]] = true;
        }
    }
    // eslint-disable-next-line max-params
    _handleCallback(name, buf, start, end) {
        if (start !== undefined && start === end) {
            return;
        }
        this.push({
            name,
            buffer: buf,
            start,
            end
        });
    }
    // eslint-disable-next-line max-statements
    _transform(buffer, _, done) {
        let i = 0;
        let prevIndex = this.index;
        let { index, state, flags } = this;
        const { lookbehind, boundary, boundaryChars } = this;
        const boundaryLength = boundary.length;
        const boundaryEnd = boundaryLength - 1;
        this.bufferLength = buffer.length;
        let c = null;
        let cl = null;
        const setMark = (name, idx)=>{
            this[`${name}Mark`] = typeof idx === 'number' ? idx : i;
        };
        const clearMarkSymbol = (name)=>{
            delete this[`${name}Mark`];
        };
        const dataCallback = (name, shouldClear)=>{
            const markSymbol = `${name}Mark`;
            if (!(markSymbol in this)) {
                return;
            }
            if (!shouldClear) {
                this._handleCallback(name, buffer, this[markSymbol], buffer.length);
                setMark(name, 0);
            } else {
                this._handleCallback(name, buffer, this[markSymbol], i);
                clearMarkSymbol(name);
            }
        };
        for(i = 0; i < this.bufferLength; i++){
            c = buffer[i];
            switch(state){
                case STATE.PARSER_UNINITIALIZED:
                    done(this._endUnexpected());
                    return;
                case STATE.START:
                    index = 0;
                    state = STATE.START_BOUNDARY;
                case STATE.START_BOUNDARY:
                    if (index === boundary.length - 2) {
                        if (c === HYPHEN) {
                            flags |= FBOUNDARY.LAST_BOUNDARY;
                        } else if (c !== CR) {
                            done(this._endUnexpected());
                            return;
                        }
                        index++;
                        break;
                    } else if (index - 1 === boundary.length - 2) {
                        if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {
                            this._handleCallback('end');
                            state = STATE.END;
                            flags = 0;
                        } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {
                            index = 0;
                            this._handleCallback('partBegin');
                            state = STATE.HEADER_FIELD_START;
                        } else {
                            done(this._endUnexpected());
                            return;
                        }
                        break;
                    }
                    if (c !== boundary[index + 2]) {
                        index = -2;
                    }
                    if (c === boundary[index + 2]) {
                        index++;
                    }
                    break;
                case STATE.HEADER_FIELD_START:
                    state = STATE.HEADER_FIELD;
                    setMark('headerField');
                    index = 0;
                case STATE.HEADER_FIELD:
                    if (c === CR) {
                        clearMarkSymbol('headerField');
                        state = STATE.HEADERS_ALMOST_DONE;
                        break;
                    }
                    index++;
                    if (c === HYPHEN) {
                        break;
                    }
                    if (c === COLON) {
                        if (index === 1) {
                            // empty header field
                            done(this._endUnexpected());
                            return;
                        }
                        dataCallback('headerField', true);
                        state = STATE.HEADER_VALUE_START;
                        break;
                    }
                    cl = lower(c);
                    if (cl < A || cl > Z) {
                        done(this._endUnexpected());
                        return;
                    }
                    break;
                case STATE.HEADER_VALUE_START:
                    if (c === SPACE) {
                        break;
                    }
                    setMark('headerValue');
                    state = STATE.HEADER_VALUE;
                case STATE.HEADER_VALUE:
                    if (c === CR) {
                        dataCallback('headerValue', true);
                        this._handleCallback('headerEnd');
                        state = STATE.HEADER_VALUE_ALMOST_DONE;
                    }
                    break;
                case STATE.HEADER_VALUE_ALMOST_DONE:
                    if (c !== LF) {
                        done(this._endUnexpected());
                        return;
                    }
                    state = STATE.HEADER_FIELD_START;
                    break;
                case STATE.HEADERS_ALMOST_DONE:
                    if (c !== LF) {
                        done(this._endUnexpected());
                        return;
                    }
                    this._handleCallback('headersEnd');
                    state = STATE.PART_DATA_START;
                    break;
                case STATE.PART_DATA_START:
                    state = STATE.PART_DATA;
                    setMark('partData');
                case STATE.PART_DATA:
                    prevIndex = index;
                    if (index === 0) {
                        // boyer-moore derived algorithm to safely skip non-boundary data
                        i += boundaryEnd;
                        while(i < this.bufferLength && !(buffer[i] in boundaryChars)){
                            i += boundaryLength;
                        }
                        i -= boundaryEnd;
                        c = buffer[i];
                    }
                    if (index < boundary.length) {
                        if (boundary[index] === c) {
                            if (index === 0) {
                                dataCallback('partData', true);
                            }
                            index++;
                        } else {
                            index = 0;
                        }
                    } else if (index === boundary.length) {
                        index++;
                        if (c === CR) {
                            // CR = part boundary
                            flags |= FBOUNDARY.PART_BOUNDARY;
                        } else if (c === HYPHEN) {
                            // HYPHEN = end boundary
                            flags |= FBOUNDARY.LAST_BOUNDARY;
                        } else {
                            index = 0;
                        }
                    } else if (index - 1 === boundary.length) {
                        if (flags & FBOUNDARY.PART_BOUNDARY) {
                            index = 0;
                            if (c === LF) {
                                // unset the PART_BOUNDARY flag
                                flags &= ~FBOUNDARY.PART_BOUNDARY;
                                this._handleCallback('partEnd');
                                this._handleCallback('partBegin');
                                state = STATE.HEADER_FIELD_START;
                                break;
                            }
                        } else if (flags & FBOUNDARY.LAST_BOUNDARY) {
                            if (c === HYPHEN) {
                                this._handleCallback('partEnd');
                                this._handleCallback('end');
                                state = STATE.END;
                                flags = 0;
                            } else {
                                index = 0;
                            }
                        } else {
                            index = 0;
                        }
                    }
                    if (index > 0) {
                        // when matching a possible boundary, keep a lookbehind reference
                        // in case it turns out to be a false lead
                        lookbehind[index - 1] = c;
                    } else if (prevIndex > 0) {
                        // if our boundary turned out to be rubbish, the captured lookbehind
                        // belongs to partData
                        this._handleCallback('partData', lookbehind, 0, prevIndex);
                        prevIndex = 0;
                        setMark('partData');
                        // reconsider the current character even so it interrupted the sequence
                        // it could be the beginning of a new sequence
                        i--;
                    }
                    break;
                case STATE.END:
                    break;
                default:
                    done(this._endUnexpected());
                    return;
            }
        }
        dataCallback('headerField');
        dataCallback('headerValue');
        dataCallback('partData');
        this.index = index;
        this.state = state;
        this.flags = flags;
        done();
        return this.bufferLength;
    }
    explain() {
        return `state = ${MultipartParser.stateToString(this.state)}`;
    }
}
// eslint-disable-next-line consistent-return
MultipartParser.stateToString = (stateNumber)=>{
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for(const stateName in STATE){
        const number = STATE[stateName];
        if (number === stateNumber) return stateName;
    }
};
const __TURBOPACK__default__export__ = Object.assign(MultipartParser, {
    STATES
});
}),
"[project]/node_modules/formidable/src/parsers/OctetStream.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
class OctetStreamParser extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["PassThrough"] {
    constructor(options = {}){
        super();
        this.globalOptions = {
            ...options
        };
    }
}
const __TURBOPACK__default__export__ = OctetStreamParser;
}),
"[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>plugin,
    "octetStreamType": ()=>octetStreamType
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$OctetStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/OctetStream.js [app-route] (ecmascript)");
;
const octetStreamType = 'octet-stream';
async function plugin(formidable, options) {
    // the `this` context is always formidable, as the first argument of a plugin
    // but this allows us to customize/test each plugin
    /* istanbul ignore next */ const self = this || formidable;
    if (/octet-stream/i.test(self.headers['content-type'])) {
        await init.call(self, self, options);
    }
    return self;
}
// Note that it's a good practice (but it's up to you) to use the `this.options` instead
// of the passed `options` (second) param, because when you decide
// to test the plugin you can pass custom `this` context to it (and so `this.options`)
async function init(_self, _opts) {
    this.type = octetStreamType;
    const originalFilename = this.headers['x-file-name'];
    const mimetype = this.headers['content-type'];
    const thisPart = {
        originalFilename,
        mimetype
    };
    const newFilename = this._getNewName(thisPart);
    const filepath = this._joinDirectoryName(newFilename);
    const file = await this._newFile({
        newFilename,
        filepath,
        originalFilename,
        mimetype
    });
    this.emit('fileBegin', originalFilename, file);
    file.open();
    this.openedFiles.push(file);
    this._flushing += 1;
    this._parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$OctetStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.options);
    // Keep track of writes that haven't finished so we don't emit the file before it's done being written
    let outstandingWrites = 0;
    this._parser.on('data', (buffer)=>{
        this.pause();
        outstandingWrites += 1;
        file.write(buffer, ()=>{
            outstandingWrites -= 1;
            this.resume();
            if (this.ended) {
                this._parser.emit('doneWritingFile');
            }
        });
    });
    this._parser.on('end', ()=>{
        this._flushing -= 1;
        this.ended = true;
        const done = ()=>{
            file.end(()=>{
                this.emit('file', 'file', file);
                this._maybeEnd();
            });
        };
        if (outstandingWrites === 0) {
            done();
        } else {
            this._parser.once('doneWritingFile', done);
        }
    });
    return this;
}
}),
"[project]/node_modules/formidable/src/parsers/Querystring.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
// This is a buffering parser, have a look at StreamingQuerystring.js for a streaming parser
class QuerystringParser extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Transform"] {
    constructor(options = {}){
        super({
            readableObjectMode: true
        });
        this.globalOptions = {
            ...options
        };
        this.buffer = '';
        this.bufferLength = 0;
    }
    _transform(buffer, encoding, callback) {
        this.buffer += buffer.toString('ascii');
        this.bufferLength = this.buffer.length;
        callback();
    }
    _flush(callback) {
        const fields = new URLSearchParams(this.buffer);
        for (const [key, value] of fields){
            this.push({
                key,
                value
            });
        }
        this.buffer = '';
        callback();
    }
}
const __TURBOPACK__default__export__ = QuerystringParser;
}),
"[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>plugin,
    "querystringType": ()=>querystringType
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Querystring.js [app-route] (ecmascript)");
;
const querystringType = 'urlencoded';
function plugin(formidable, options) {
    // the `this` context is always formidable, as the first argument of a plugin
    // but this allows us to customize/test each plugin
    /* istanbul ignore next */ const self = this || formidable;
    if (/urlencoded/i.test(self.headers['content-type'])) {
        init.call(self, self, options);
    }
    return self;
}
;
// Note that it's a good practice (but it's up to you) to use the `this.options` instead
// of the passed `options` (second) param, because when you decide
// to test the plugin you can pass custom `this` context to it (and so `this.options`)
function init(_self, _opts) {
    this.type = querystringType;
    const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.options);
    parser.on('data', ({ key, value })=>{
        this.emit('field', key, value);
    });
    parser.once('end', ()=>{
        this.ended = true;
        this._maybeEnd();
    });
    this._parser = parser;
    return this;
}
}),
"[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>plugin,
    "multipartType": ()=>multipartType
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)");
;
;
;
;
const multipartType = 'multipart';
function plugin(formidable, options) {
    // the `this` context is always formidable, as the first argument of a plugin
    // but this allows us to customize/test each plugin
    /* istanbul ignore next */ const self = this || formidable;
    // NOTE: we (currently) support both multipart/form-data and multipart/related
    const multipart = /multipart/i.test(self.headers['content-type']);
    if (multipart) {
        const m = self.headers['content-type'].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
        if (m) {
            const initMultipart = createInitMultipart(m[1] || m[2]);
            initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]
        } else {
            const err = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('bad content-type header, no multipart boundary', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["missingMultipartBoundary"], 400);
            self._error(err);
        }
    }
    return self;
}
// Note that it's a good practice (but it's up to you) to use the `this.options` instead
// of the passed `options` (second) param, because when you decide
// to test the plugin you can pass custom `this` context to it (and so `this.options`)
function createInitMultipart(boundary) {
    return function initMultipart() {
        this.type = multipartType;
        const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.options);
        let headerField;
        let headerValue;
        let part;
        parser.initWithBoundary(boundary);
        // eslint-disable-next-line max-statements, consistent-return
        parser.on('data', async ({ name, buffer, start, end })=>{
            if (name === 'partBegin') {
                part = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Stream"]();
                part.readable = true;
                part.headers = {};
                part.name = null;
                part.originalFilename = null;
                part.mimetype = null;
                part.transferEncoding = this.options.encoding;
                part.transferBuffer = '';
                headerField = '';
                headerValue = '';
            } else if (name === 'headerField') {
                headerField += buffer.toString(this.options.encoding, start, end);
            } else if (name === 'headerValue') {
                headerValue += buffer.toString(this.options.encoding, start, end);
            } else if (name === 'headerEnd') {
                headerField = headerField.toLowerCase();
                part.headers[headerField] = headerValue;
                // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
                const m = headerValue.match(// eslint-disable-next-line no-useless-escape
                /\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i);
                if (headerField === 'content-disposition') {
                    if (m) {
                        part.name = m[2] || m[3] || '';
                    }
                    part.originalFilename = this._getFileName(headerValue);
                } else if (headerField === 'content-type') {
                    part.mimetype = headerValue;
                } else if (headerField === 'content-transfer-encoding') {
                    part.transferEncoding = headerValue.toLowerCase();
                }
                headerField = '';
                headerValue = '';
            } else if (name === 'headersEnd') {
                switch(part.transferEncoding){
                    case 'binary':
                    case '7bit':
                    case '8bit':
                    case 'utf-8':
                        {
                            const dataPropagation = (ctx)=>{
                                if (ctx.name === 'partData') {
                                    part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));
                                }
                            };
                            const dataStopPropagation = (ctx)=>{
                                if (ctx.name === 'partEnd') {
                                    part.emit('end');
                                    parser.off('data', dataPropagation);
                                    parser.off('data', dataStopPropagation);
                                }
                            };
                            parser.on('data', dataPropagation);
                            parser.on('data', dataStopPropagation);
                            break;
                        }
                    case 'base64':
                        {
                            const dataPropagation = (ctx)=>{
                                if (ctx.name === 'partData') {
                                    part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString('ascii');
                                    /*
                  four bytes (chars) in base64 converts to three bytes in binary
                  encoding. So we should always work with a number of bytes that
                  can be divided by 4, it will result in a number of bytes that
                  can be divided vy 3.
                  */ const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
                                    part.emit('data', Buffer.from(part.transferBuffer.substring(0, offset), 'base64'));
                                    part.transferBuffer = part.transferBuffer.substring(offset);
                                }
                            };
                            const dataStopPropagation = (ctx)=>{
                                if (ctx.name === 'partEnd') {
                                    part.emit('data', Buffer.from(part.transferBuffer, 'base64'));
                                    part.emit('end');
                                    parser.off('data', dataPropagation);
                                    parser.off('data', dataStopPropagation);
                                }
                            };
                            parser.on('data', dataPropagation);
                            parser.on('data', dataStopPropagation);
                            break;
                        }
                    default:
                        return this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('unknown transfer-encoding', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unknownTransferEncoding"], 501));
                }
                this._parser.pause();
                await this.onPart(part);
                this._parser.resume();
            } else if (name === 'end') {
                this.ended = true;
                this._maybeEnd();
            }
        });
        this._parser = parser;
    };
}
}),
"[project]/node_modules/formidable/src/parsers/JSON.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
class JSONParser extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Transform"] {
    constructor(options = {}){
        super({
            readableObjectMode: true
        });
        this.chunks = [];
        this.globalOptions = {
            ...options
        };
    }
    _transform(chunk, encoding, callback) {
        this.chunks.push(String(chunk)); // todo consider using a string decoder
        callback();
    }
    _flush(callback) {
        try {
            const fields = JSON.parse(this.chunks.join(''));
            this.push(fields);
        } catch (e) {
            callback(e);
            return;
        }
        this.chunks = null;
        callback();
    }
}
const __TURBOPACK__default__export__ = JSONParser;
}),
"[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "default": ()=>plugin,
    "jsonType": ()=>jsonType
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$JSON$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/JSON.js [app-route] (ecmascript)");
;
const jsonType = 'json';
function plugin(formidable, options) {
    // the `this` context is always formidable, as the first argument of a plugin
    // but this allows us to customize/test each plugin
    /* istanbul ignore next */ const self = this || formidable;
    if (/json/i.test(self.headers['content-type'])) {
        init.call(self, self, options);
    }
    return self;
}
;
// Note that it's a good practice (but it's up to you) to use the `this.options` instead
// of the passed `options` (second) param, because when you decide
// to test the plugin you can pass custom `this` context to it (and so `this.options`)
function init(_self, _opts) {
    this.type = jsonType;
    const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$JSON$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.options);
    parser.on('data', (fields)=>{
        this.fields = fields;
    });
    parser.once('end', ()=>{
        this.ended = true;
        this._maybeEnd();
    });
    this._parser = parser;
}
}),
"[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript)");
;
;
;
;
;
}),
"[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript) <export default as json>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "json": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript)");
}),
"[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript) <export default as multipart>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "multipart": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript)");
}),
"[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript) <export default as octetstream>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "octetstream": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript)");
}),
"[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript) <export default as querystring>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "querystring": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript)");
}),
"[project]/node_modules/formidable/src/Formidable.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable class-methods-use-this */ /* eslint-disable no-underscore-dangle */ __turbopack_context__.s({
    "DEFAULT_OPTIONS": ()=>DEFAULT_OPTIONS,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$paralleldrive$2f$cuid2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@paralleldrive/cuid2/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dezalgo$2f$dezalgo$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dezalgo/dezalgo.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:string_decoder [external] (node:string_decoder, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$once$2f$once$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/once/once.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$PersistentFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/PersistentFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$VolatileFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/VolatileFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Dummy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Dummy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__json$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/json.js [app-route] (ecmascript) <export default as json>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__multipart$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/multipart.js [app-route] (ecmascript) <export default as multipart>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__octetstream$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/octetstream.js [app-route] (ecmascript) <export default as octetstream>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__querystring$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/querystring.js [app-route] (ecmascript) <export default as querystring>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const CUID2_FINGERPRINT = `${("TURBOPACK compile-time value", "development")}-${__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].platform()}-${__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].hostname()}`;
const createId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$paralleldrive$2f$cuid2$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["init"])({
    length: 25,
    fingerprint: CUID2_FINGERPRINT.toLowerCase()
});
const DEFAULT_OPTIONS = {
    maxFields: 1000,
    maxFieldsSize: 20 * 1024 * 1024,
    maxFiles: Infinity,
    maxFileSize: 200 * 1024 * 1024,
    maxTotalFileSize: undefined,
    minFileSize: 1,
    allowEmptyFiles: false,
    createDirsFromUploads: false,
    keepExtensions: false,
    encoding: 'utf-8',
    hashAlgorithm: false,
    uploadDir: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].tmpdir(),
    enabledPlugins: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$octetstream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__octetstream$3e$__["octetstream"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__querystring$3e$__["querystring"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__multipart$3e$__["multipart"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$json$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__json$3e$__["json"]
    ],
    fileWriteStreamHandler: null,
    defaultInvalidName: 'invalid-name',
    filter (_part) {
        return true;
    },
    filename: undefined
};
function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
const decorateForceSequential = function(promiseCreator) {
    /* forces a function that returns a promise to be sequential
  useful for fs  for example */ let lastPromise = Promise.resolve();
    return async function(...x) {
        const promiseWeAreWaitingFor = lastPromise;
        let currentPromise;
        let callback;
        // we need to change lastPromise before await anything,
        // otherwise 2 calls might wait the same thing
        lastPromise = new Promise(function(resolve) {
            callback = resolve;
        });
        await promiseWeAreWaitingFor;
        currentPromise = promiseCreator(...x);
        currentPromise.then(callback).catch(callback);
        return currentPromise;
    };
};
const createNecessaryDirectoriesAsync = decorateForceSequential(function(filePath) {
    const directoryname = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(filePath);
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].mkdir(directoryname, {
        recursive: true
    });
});
const invalidExtensionChar = (c)=>{
    const code = c.charCodeAt(0);
    return !(code === 46 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122);
};
class IncomingForm extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["EventEmitter"] {
    constructor(options = {}){
        super();
        this.options = {
            ...DEFAULT_OPTIONS,
            ...options
        };
        if (!this.options.maxTotalFileSize) {
            this.options.maxTotalFileSize = this.options.maxFileSize;
        }
        const dir = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(this.options.uploadDir || this.options.uploaddir || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["default"].tmpdir());
        this.uploaddir = dir;
        this.uploadDir = dir;
        // initialize with null
        [
            'error',
            'headers',
            'type',
            'bytesExpected',
            'bytesReceived',
            '_parser',
            'req'
        ].forEach((key)=>{
            this[key] = null;
        });
        this._setUpRename();
        this._flushing = 0;
        this._fieldsSize = 0;
        this._totalFileSize = 0;
        this._plugins = [];
        this.openedFiles = [];
        this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);
        if (this.options.enabledPlugins.length === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('expect at least 1 enabled builtin plugin, see options.enabledPlugins', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["missingPlugin"]);
        }
        this.options.enabledPlugins.forEach((plugin)=>{
            this.use(plugin);
        });
        this._setUpMaxFields();
        this._setUpMaxFiles();
        this.ended = undefined;
        this.type = undefined;
    }
    use(plugin) {
        if (typeof plugin !== 'function') {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('.use: expect `plugin` to be a function', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pluginFunction"]);
        }
        this._plugins.push(plugin.bind(this));
        return this;
    }
    pause() {
        try {
            this.req.pause();
        } catch (err) {
            // the stream was destroyed
            if (!this.ended) {
                // before it was completed, crash & burn
                this._error(err);
            }
            return false;
        }
        return true;
    }
    resume() {
        try {
            this.req.resume();
        } catch (err) {
            // the stream was destroyed
            if (!this.ended) {
                // before it was completed, crash & burn
                this._error(err);
            }
            return false;
        }
        return true;
    }
    // returns a promise if no callback is provided
    async parse(req, cb) {
        this.req = req;
        let promise;
        // Setup callback first, so we don't miss anything from data events emitted immediately.
        if (!cb) {
            let resolveRef;
            let rejectRef;
            promise = new Promise((resolve, reject)=>{
                resolveRef = resolve;
                rejectRef = reject;
            });
            cb = (err, fields, files)=>{
                if (err) {
                    rejectRef(err);
                } else {
                    resolveRef([
                        fields,
                        files
                    ]);
                }
            };
        }
        const callback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$once$2f$once$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dezalgo$2f$dezalgo$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(cb));
        this.fields = {};
        const files = {};
        this.on('field', (name, value)=>{
            if (this.type === 'multipart' || this.type === 'urlencoded') {
                if (!hasOwnProp(this.fields, name)) {
                    this.fields[name] = [
                        value
                    ];
                } else {
                    this.fields[name].push(value);
                }
            } else {
                this.fields[name] = value;
            }
        });
        this.on('file', (name, file)=>{
            if (!hasOwnProp(files, name)) {
                files[name] = [
                    file
                ];
            } else {
                files[name].push(file);
            }
        });
        this.on('error', (err)=>{
            callback(err, this.fields, files);
        });
        this.on('end', ()=>{
            callback(null, this.fields, files);
        });
        // Parse headers and setup the parser, ready to start listening for data.
        await this.writeHeaders(req.headers);
        // Start listening for data.
        req.on('error', (err)=>{
            this._error(err);
        }).on('aborted', ()=>{
            this.emit('aborted');
            this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('Request aborted', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["aborted"]));
        }).on('data', (buffer)=>{
            try {
                this.write(buffer);
            } catch (err) {
                this._error(err);
            }
        }).on('end', ()=>{
            if (this.error) {
                return;
            }
            if (this._parser) {
                this._parser.end();
            }
        });
        if (promise) {
            return promise;
        }
        return this;
    }
    async writeHeaders(headers) {
        this.headers = headers;
        this._parseContentLength();
        await this._parseContentType();
        if (!this._parser) {
            this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('no parser found', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["noParser"], 415));
            return;
        }
        this._parser.once('error', (error)=>{
            this._error(error);
        });
    }
    write(buffer) {
        if (this.error) {
            return null;
        }
        if (!this._parser) {
            this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('uninitialized parser', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["uninitializedParser"]));
            return null;
        }
        this.bytesReceived += buffer.length;
        this.emit('progress', this.bytesReceived, this.bytesExpected);
        this._parser.write(buffer);
        return this.bytesReceived;
    }
    onPart(part) {
        // this method can be overwritten by the user
        return this._handlePart(part);
    }
    async _handlePart(part) {
        if (part.originalFilename && typeof part.originalFilename !== 'string') {
            this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`the part.originalFilename should be string when it exists`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["filenameNotString"]));
            return;
        }
        // This MUST check exactly for undefined. You can not change it to !part.originalFilename.
        // todo: uncomment when switch tests to Jest
        // console.log(part);
        // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned
        // from somewhere else. Where recently I changed the return statements
        // and such thing because code style
        // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field
        // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?
        if (!part.mimetype) {
            let value = '';
            const decoder = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__["StringDecoder"](part.transferEncoding || this.options.encoding);
            part.on('data', (buffer)=>{
                this._fieldsSize += buffer.length;
                if (this._fieldsSize > this.options.maxFieldsSize) {
                    this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["maxFieldsSizeExceeded"], 413));
                    return;
                }
                value += decoder.write(buffer);
            });
            part.on('end', ()=>{
                this.emit('field', part.name, value);
            });
            return;
        }
        if (!this.options.filter(part)) {
            return;
        }
        this._flushing += 1;
        let fileSize = 0;
        const newFilename = this._getNewName(part);
        const filepath = this._joinDirectoryName(newFilename);
        const file = await this._newFile({
            newFilename,
            filepath,
            originalFilename: part.originalFilename,
            mimetype: part.mimetype
        });
        file.on('error', (err)=>{
            this._error(err);
        });
        this.emit('fileBegin', part.name, file);
        file.open();
        this.openedFiles.push(file);
        part.on('data', (buffer)=>{
            this._totalFileSize += buffer.length;
            fileSize += buffer.length;
            if (this._totalFileSize > this.options.maxTotalFileSize) {
                this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["biggerThanTotalMaxFileSize"], 413));
                return;
            }
            if (buffer.length === 0) {
                return;
            }
            this.pause();
            file.write(buffer, ()=>{
                this.resume();
            });
        });
        part.on('end', ()=>{
            if (!this.options.allowEmptyFiles && fileSize === 0) {
                this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.allowEmptyFiles is false, file size should be greater than 0`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["noEmptyFiles"], 400));
                return;
            }
            if (fileSize < this.options.minFileSize) {
                this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["smallerThanMinFileSize"], 400));
                return;
            }
            if (fileSize > this.options.maxFileSize) {
                this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["biggerThanMaxFileSize"], 413));
                return;
            }
            file.end(()=>{
                this._flushing -= 1;
                this.emit('file', part.name, file);
                this._maybeEnd();
            });
        });
    }
    // eslint-disable-next-line max-statements
    async _parseContentType() {
        if (this.bytesExpected === 0) {
            this._parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Dummy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this, this.options);
            return;
        }
        if (!this.headers['content-type']) {
            this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]('bad content-type header, no content-type', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["missingContentType"], 400));
            return;
        }
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Dummy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this, this.options);
        const results = [];
        await Promise.all(this._plugins.map(async (plugin, idx)=>{
            let pluginReturn = null;
            try {
                pluginReturn = await plugin(this, this.options) || this;
            } catch (err) {
                // directly throw from the `form.parse` method;
                // there is no other better way, except a handle through options
                const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`plugin on index ${idx} failed with: ${err.message}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pluginFailed"], 500);
                error.idx = idx;
                throw error;
            }
            Object.assign(this, pluginReturn);
            // todo: use Set/Map and pass plugin name instead of the `idx` index
            this.emit('plugin', idx, pluginReturn);
        }));
        this.emit('pluginsResults', results);
    }
    _error(err, eventName = 'error') {
        if (this.error || this.ended) {
            return;
        }
        this.req = null;
        this.error = err;
        this.emit(eventName, err);
        this.openedFiles.forEach((file)=>{
            file.destroy();
        });
    }
    _parseContentLength() {
        this.bytesReceived = 0;
        if (this.headers['content-length']) {
            this.bytesExpected = parseInt(this.headers['content-length'], 10);
        } else if (this.headers['transfer-encoding'] === undefined) {
            this.bytesExpected = 0;
        }
        if (this.bytesExpected !== null) {
            this.emit('progress', this.bytesReceived, this.bytesExpected);
        }
    }
    _newParser() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.options);
    }
    async _newFile({ filepath, originalFilename, mimetype, newFilename }) {
        if (this.options.fileWriteStreamHandler) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$VolatileFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                newFilename,
                filepath,
                originalFilename,
                mimetype,
                createFileWriteStream: this.options.fileWriteStreamHandler,
                hashAlgorithm: this.options.hashAlgorithm
            });
        }
        if (this.options.createDirsFromUploads) {
            try {
                await createNecessaryDirectoriesAsync(filepath);
            } catch (errorCreatingDir) {
                this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`cannot create directory`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cannotCreateDir"], 409));
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$PersistentFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            newFilename,
            filepath,
            originalFilename,
            mimetype,
            hashAlgorithm: this.options.hashAlgorithm
        });
    }
    _getFileName(headerValue) {
        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
        const m = headerValue.match(/\bfilename=("(.*?)"|([^()<>{}[\]@,;:"?=\s/\t]+))($|;\s)/i);
        if (!m) return null;
        const match = m[2] || m[3] || '';
        let originalFilename = match.substr(match.lastIndexOf('\\') + 1);
        originalFilename = originalFilename.replace(/%22/g, '"');
        originalFilename = originalFilename.replace(/&#([\d]{4});/g, (_, code)=>String.fromCharCode(code));
        return originalFilename;
    }
    // able to get composed extension with multiple dots
    // "a.b.c" -> ".b.c"
    // as opposed to path.extname -> ".c"
    _getExtension(str) {
        if (!str) {
            return '';
        }
        const basename = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].basename(str);
        const firstDot = basename.indexOf('.');
        const lastDot = basename.lastIndexOf('.');
        let rawExtname = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].extname(basename);
        if (firstDot !== lastDot) {
            rawExtname = basename.slice(firstDot);
        }
        let filtered;
        const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);
        if (firstInvalidIndex === -1) {
            filtered = rawExtname;
        } else {
            filtered = rawExtname.substring(0, firstInvalidIndex);
        }
        if (filtered === '.') {
            return '';
        }
        return filtered;
    }
    _joinDirectoryName(name) {
        const newPath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(this.uploadDir, name);
        // prevent directory traversal attacks
        if (!newPath.startsWith(this.uploadDir)) {
            return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(this.uploadDir, this.options.defaultInvalidName);
        }
        return newPath;
    }
    _setUpRename() {
        const hasRename = typeof this.options.filename === 'function';
        if (hasRename) {
            this._getNewName = (part)=>{
                let ext = '';
                let name = this.options.defaultInvalidName;
                if (part.originalFilename) {
                    // can be null
                    ({ ext, name } = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].parse(part.originalFilename));
                    if (this.options.keepExtensions !== true) {
                        ext = '';
                    }
                }
                return this.options.filename.call(this, name, ext, part, this);
            };
        } else {
            this._getNewName = (part)=>{
                const name = createId();
                if (part && this.options.keepExtensions) {
                    const originalFilename = typeof part === 'string' ? part : part.originalFilename;
                    return `${name}${this._getExtension(originalFilename)}`;
                }
                return name;
            };
        }
    }
    _setUpMaxFields() {
        if (this.options.maxFields !== Infinity) {
            let fieldsCount = 0;
            this.on('field', ()=>{
                fieldsCount += 1;
                if (fieldsCount > this.options.maxFields) {
                    this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.maxFields (${this.options.maxFields}) exceeded`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["maxFieldsExceeded"], 413));
                }
            });
        }
    }
    _setUpMaxFiles() {
        if (this.options.maxFiles !== Infinity) {
            let fileCount = 0;
            this.on('fileBegin', ()=>{
                fileCount += 1;
                if (fileCount > this.options.maxFiles) {
                    this._error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](`options.maxFiles (${this.options.maxFiles}) exceeded`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["maxFilesExceeded"], 413));
                }
            });
        }
    }
    _maybeEnd() {
        if (!this.ended || this._flushing || this.error) {
            return;
        }
        this.req = null;
        this.emit('end');
    }
}
const __TURBOPACK__default__export__ = IncomingForm;
;
}),
"[project]/node_modules/formidable/src/parsers/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$JSON$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/JSON.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Dummy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Dummy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$OctetStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/OctetStream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Querystring.js [app-route] (ecmascript)");
;
;
;
;
;
;
}),
"[project]/node_modules/formidable/src/parsers/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$JSON$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/JSON.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Dummy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Dummy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Multipart$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Multipart.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$OctetStream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/OctetStream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$Querystring$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/Querystring.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/formidable/src/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__,
    "enabledPlugins": ()=>enabledPlugins,
    "formidable": ()=>formidable
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$PersistentFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/PersistentFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$VolatileFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/VolatileFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$Formidable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/Formidable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)");
;
;
;
// make it available without requiring the `new` keyword
// if you want it access `const formidable.IncomingForm` as v1
const formidable = (...args)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$Formidable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](...args);
const { enabledPlugins } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$Formidable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEFAULT_OPTIONS"];
const __TURBOPACK__default__export__ = formidable;
;
;
;
;
}),
"[project]/node_modules/formidable/src/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$PersistentFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/PersistentFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$VolatileFile$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/VolatileFile.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$Formidable$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/Formidable.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$parsers$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/parsers/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$plugins$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/plugins/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$FormidableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/FormidableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$formidable$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/formidable/src/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@noble/hashes/_u64.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64; //# sourceMappingURL=_u64.js.map
}}),
"[project]/node_modules/@noble/hashes/cryptoNode.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */ // @ts-ignore
const nc = __turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs)");
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : nc && typeof nc === 'object' && 'randomBytes' in nc ? nc : undefined; //# sourceMappingURL=cryptoNode.js.map
}}),
"[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/cryptoNode.js [app-route] (ecmascript)");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */ function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);
/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */ function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */ const nextTick = async ()=>{};
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */ function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */ class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@noble/hashes/sha3.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ const _u64_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_u64.js [app-route] (ecmascript)");
// prettier-ignore
const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta θ
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map
}}),
"[project]/node_modules/@paralleldrive/cuid2/src/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* global global, window, module */ const { sha3_512: sha3 } = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha3.js [app-route] (ecmascript)");
const defaultLength = 24;
const bigLength = 32;
const createEntropy = (length = 4, random = Math.random)=>{
    let entropy = "";
    while(entropy.length < length){
        entropy = entropy + Math.floor(random() * 36).toString(36);
    }
    return entropy;
};
/*
 * Adapted from https://github.com/juanelas/bigint-conversion
 * MIT License Copyright (c) 2018 Juan Hernández Serrano
 */ function bufToBigInt(buf) {
    let bits = 8n;
    let value = 0n;
    for (const i of buf.values()){
        const bi = BigInt(i);
        value = (value << bits) + bi;
    }
    return value;
}
const hash = (input = "")=>{
    // Drop the first character because it will bias the histogram
    // to the left.
    return bufToBigInt(sha3(input)).toString(36).slice(1);
};
const alphabet = Array.from({
    length: 26
}, (x, i)=>String.fromCharCode(i + 97));
const randomLetter = (random)=>alphabet[Math.floor(random() * alphabet.length)];
/*
This is a fingerprint of the host environment. It is used to help
prevent collisions when generating ids in a distributed system.
If no global object is available, you can pass in your own, or fall back
on a random string.
*/ const createFingerprint = ({ globalObj = ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK ident replacement", globalThis) : "TURBOPACK unreachable", random = Math.random } = {})=>{
    const globals = Object.keys(globalObj).toString();
    const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
    return hash(sourceString).substring(0, bigLength);
};
const createCounter = (count)=>()=>{
        return count++;
    };
// ~22k hosts before 50% chance of initial counter collision
// with a remaining counter range of 9.0e+15 in JavaScript.
const initialCountMax = 476782367;
const init = ({ // Fallback if the user does not pass in a CSPRNG. This should be OK
// because we don't rely solely on the random number generator for entropy.
// We also use the host fingerprint, current time, and a session counter.
random = Math.random, counter = createCounter(Math.floor(random() * initialCountMax)), length = defaultLength, fingerprint = createFingerprint({
    random
}) } = {})=>{
    return function cuid2() {
        const firstLetter = randomLetter(random);
        // If we're lucky, the `.toString(36)` calls may reduce hashing rounds
        // by shortening the input to the hash function a little.
        const time = Date.now().toString(36);
        const count = counter().toString(36);
        // The salt should be long enough to be globally unique across the full
        // length of the hash. For simplicity, we use the same length as the
        // intended id output.
        const salt = createEntropy(length, random);
        const hashInput = `${time + salt + count + fingerprint}`;
        return `${firstLetter + hash(hashInput).substring(1, length)}`;
    };
};
const createId = init();
const isCuid = (id, { minLength = 2, maxLength = bigLength } = {})=>{
    const length = id.length;
    const regex = /^[0-9a-z]+$/;
    try {
        if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id)) return true;
    } finally{}
    return false;
};
module.exports.getConstants = ()=>({
        defaultLength,
        bigLength
    });
module.exports.init = init;
module.exports.createId = createId;
module.exports.bufToBigInt = bufToBigInt;
module.exports.createCounter = createCounter;
module.exports.createFingerprint = createFingerprint;
module.exports.isCuid = isCuid;
}}),
"[project]/node_modules/@paralleldrive/cuid2/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createId, init, getConstants, isCuid } = __turbopack_context__.r("[project]/node_modules/@paralleldrive/cuid2/src/index.js [app-route] (ecmascript)");
module.exports.createId = createId;
module.exports.init = init;
module.exports.getConstants = getConstants;
module.exports.isCuid = isCuid;
}}),
"[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    //TURBOPACK unreachable
    ;
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}}),
"[project]/node_modules/asap/raw.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";
// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}
var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;
// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while(index < queue.length){
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++){
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}
rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = __turbopack_context__.r("[externals]/domain [external] (domain, cjs)");
        }
        domain.active = process.domain = null;
    }
    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }
    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}
}}),
"[project]/node_modules/asap/asap.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var rawAsap = __turbopack_context__.r("[project]/node_modules/asap/raw.js [app-route] (ecmascript)");
var freeTasks = [];
/**
 * Calls a task as soon as possible after returning, in its own event, with
 * priority over IO events. An exception thrown in a task can be handled by
 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
 * crash the process. If the error is handled, all subsequent tasks will
 * resume.
 *
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawTask.domain = process.domain;
    rawAsap(rawTask);
}
function RawTask() {
    this.task = null;
    this.domain = null;
}
RawTask.prototype.call = function() {
    if (this.domain) {
        this.domain.enter();
    }
    var threw = true;
    try {
        this.task.call();
        threw = false;
        // If the task throws an exception (presumably) Node.js restores the
        // domain stack for the next event.
        if (this.domain) {
            this.domain.exit();
        }
    } finally{
        // We use try/finally and a threw flag to avoid messing up stack traces
        // when we catch and release errors.
        if (threw) {
            // In Node.js, uncaught exceptions are considered fatal errors.
            // Re-throw them to interrupt flushing!
            // Ensure that flushing continues if an uncaught exception is
            // suppressed listening process.on("uncaughtException") or
            // domain.on("error").
            rawAsap.requestFlush();
        }
        // If the task threw an error, we do not want to exit the domain here.
        // Exiting the domain would prevent the domain from catching the error.
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
    }
};
}}),
"[project]/node_modules/dezalgo/dezalgo.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)");
module.exports = wrappy(dezalgo);
var asap = __turbopack_context__.r("[project]/node_modules/asap/asap.js [app-route] (ecmascript)");
function dezalgo(cb) {
    var sync = true;
    asap(function() {
        sync = false;
    });
    return function zalgoSafe() {
        var args = arguments;
        var me = this;
        if (sync) asap(function() {
            cb.apply(me, args);
        });
        else cb.apply(me, args);
    };
}
}}),
"[project]/node_modules/once/once.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-route] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}}),

};

//# sourceMappingURL=node_modules_9c9f5af8._.js.map